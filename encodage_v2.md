# Les encodages

Commençons par la toute base : les nombres sont les seuls choses que puissent "comprendre" les ordinateurs.

Il s'avère qu'en raison de contraintes métaphysiques les nombres que manipule les ordinateurs sont forcés d'être représentés en numération binaire, ce qui explique pourquoi les chiffres desdits nombres portent le nom de __bit__ (acronyme de __binary digit__, ou __chiffre binaire__ en français).
En électronique, un bit représente une plage de tension électrique, mais dans ce document nous nous contenterons de la représentation aussi conventionnelle qu'abstraite d'un bit à $0$ ou $1$.
Tout nombre que manipule un ordinateur est ainsi constitué d'un ensemble fini de bit, du nom de __champ binaire__, dont la taille se limite aux divers capacités de stockage des _registres*_ d'un microprocesseur (ce qui prend en compte l'_aliasing de registres*_).

Toutefois, sachez que la représentation des nombres dans un ordinateur est dictée par ce que l'on appelle des __encodages__, chacun d'entre eux étant cependant contraint de ne représenter des nombres soit naturels, soit relatifs, soit réels.

ne pouvant représenter des nombres ne provenant que d'un seul et unique ensemble, 


certains d'entre eux n'ayant la capacité de représenter que des nombres naturels, d'autres des nombres relatifs ou encore réels.

chacun d'entre eux n'ayant la capacité de représenter que des nombres soit naturels, soit relatifs ou soit réels.

chacun d'entre eux ne pouvant représenter que des nombres provenent d'un seul des ensembles naturels, relatifs ou réels.


chaque __encodage__ ne pouvant représenter soit que des nombres naturels, relatifs ou encore réels. 

ces derniers n'étant capable de représenter que des nombres faisant partis d'un unique ensemble tel que les réels, les relatifs ou les naturels.

Toutefois, sachez que la représentation des nombres dans un ordinateur est dictée par ce que l'on appelle un __encodage__.
Il s'avère que tout __encodage__ n'est cependant capable de représenter que des nombres faisant partis d'un ensemble tel que les réels, les relatifs ou les naturels.

Dans la pratique, un __encodage__ ne permet de représenter que des nombres faisant partis de l'ensemble des réels, de l'ensemble des relatifs ou des naturels.




Il s'avère qu'un __encodage__ ne fait que définir la valeur des bits qui composent un __champ binaire__, en plus d'établir les calculs à réalisés entre les valeurs de chacun desdits bits.

//

Toutefois, sachez que les nombres manipulés par un ordinateur, constitué d'un __champ binaire__, ont une représentation qui est dictée par ce que l'on appelle un __encodage__.
Il s'avère qu'un __encodage__ ne fait que définir la valeur des bits qui composent un __champ binaire__, en plus d'établir les calculs à réalisés entre les valeurs de chacun desdits bits.
Dans les faits, un __encodage__ ne peut représenter que des nombres réels, relatifs ou encore naturels.










///

Dans les faits, l'__encodage__ définit les méthodes de calcul avec lesquels nous attribuons une valeur aux bits qui composent un __champ binaire__, en plus des calculs à réalisés entre les valeurs des bits eux même afin d'obtenir la valeur d'un nombre.

Dans les faits, l'__encodage__ définit les méthodes de calcul avec lesquels nous attribuons une valeur aux bits composant un __champ binaire__, en plus des calculs à réalisés entre les valeurs desdits bits afin d'obtenir la valeur d'un nombre.

Vous l'aurez cependant compris, il n'existe pas qu'un seul encodage mais plusieurs ...

Dans la théorie, il existe un nombre inquantifiable d'__encodage__, tout les nombres ne pouvant pas être efficassement représentés par le seul et unique biais d'un __encodage__.


/// exemple encodage

/// Dans les faits, un __encodage__ est au croisement entre la polyvalence de représentation des nombres (entier naturel, à virgule, etc.) et la capacité de codage de ces nombres.

///

Sachez qu'il y a cependant d'innombrable façons de représenter des nombres au travers d'un __champ binaire__, chaque représentation étant la conséquence de ce que l'on appelle un __encodage__. 
Les __encodages__ permettent de représenter des nombres en suivant une méthodologie de calcul qui : attribue une valeur à l'ensemble des chiffres composant un nombre, ainsi que définit les calculs à produire entre les valeurs desdits chiffres.



///

Sachez qu'il y a cependant d'innombrable façons de représenter des nombres au travers d'un __champ binaire__, cela s'appelle l'__encodage des champs__ ou l'__encodage des nombres__ et dans la suite du document nous appellerons fréquemment cela l'__encodage__.
Un __encodage__ permet de représenter des nombres en suivant une méthodologie de calcul qui : attribue une valeur à l'ensemble des chiffres composant un nombre, ainsi que définit les calculs à produire entre les valeurs desdits chiffres.



___Définitions___

___Registre__ : Mémoire de très faible capacité aux temps d'accès extrêmement court qui est intégré à l'architecture des microprocesseurs.
Compte tenu de leurs faible temps d'accès, les registres sont les supports de mémorisation les plus sollicités par les instructions machines de l'interface externe des microprocesseurs, et même les seuls sollicités dans le cas des architectures Load-Store._

___Aliasing de registres__ : Système contribuant à la rétrocompatibilité des microprocesseurs en assurant la compatibilité descendante des registres.
En d'autres termes, ce système d'aliasing permet (entre autre) aux registres des microprocesseurs 64 bits d'être aliasé pour ce qu'ils sont, ou de l'être comme s'ils étaient des registres de microprocesseurs de 32, 16 ou 8 bits._



//

Commençons par la base : les nombres sont les seuls choses que manipule un ordinateur.

Cela explique pourquoi tout traitement informatique n'est qu'une suite de calcul plus ou moins complexe, ainsi que la nécessité de numériser toute information (son, image, document) devant être inscrite dans la mémoire d'un ordinateur.
En raison de contrainte physique, les nombres que manipule un ordinateur sont composés de ce que l'on appelle des __bit__ (acronyme de __binary digit__, __chiffre binaire__ en français) qui représente symboliquement un $0$ ou un $1$.

Cependant, en raison de contrainte physique, les ordinateurs 

// try 2

Commençons par la base : les nombres sont les seuls choses que manipule un ordinateur.

Cela explique pourquoi tout traitement informatique n'est qu'une suite de calcul plus ou moins complexe, ainsi que la nécessité de numériser toute information (son, image, document) devant être inscrite dans la mémoire d'un ordinateur.
Il s'avère que pour des raisons de sécurité et de fiabilité, les nombres que manipule un ordinateur sont forcés d'être représenté en numération binaire, lesdits nombres sont alors composés d'un ensemble de __bit__ (acronyme de __binary digit__, __chiffre binaire__ en français).
En électronique, un bit représente une plage de tension électrique, mais dans ce document nous nous contenterons de la représentation conventionnelle et abstraite d'un bit interprétant un $0$ ou un $1$.

Comme susmentionné, les nombres dans un ordinateur sont composés d'un ensemble de bit, et cet ensemble de bit porte le nom de __champ binaire__.
Seulement, au travers de ces __champs binaire__ il y a d'innombrable façons de représenter des nombres, cela s'appelle l'__encodage__ ou l'__encodage des nombres__.

/// trouver une solution pour parler de l'encodage des nombres (ex: reformuler les choses dans le premier paragraphe)

// try 1

Commençons par la base.

Fondamentalement, toute tâche effectuée par un ordinateur revient à une suite de calcul plus ou moins complexe, car un ordinateur ne peut mémoriser des informations que sous une forme numérisée.

En informatique, un bit est symboliquement représenté par un $0$ ou un $1$, de plus, sachez pour votre culture que le terme __bit__ est l'acronyme de __binary digit__ (__chiffre binaire__ en français).
Dans le fond, quoi que fasse un ordinateur, il ne manipule jamais plus que des nombres composés d'un ensemble de bit, des nombres binaires, ces ensembles de bit portent le nom de __champs binaires__ ou simplement de __champs__.
Seulement, au travers de ces __champs binaire__ il y a d'innombrable façons de représenter des nombres, cela s'appelle l'__encodage des champs__ ou l'__encodage des nombres__, si ce n'est l'__encodage__ tout court.

Par essence, tout les __encodages__ ne se valent pas, car tous se spécialisent dans la représentation de nombres entiers naturel, relatif, ou dans les nombres à virgule pour les plus polyvalents.
Veuillez cependant noter que la ployvalence desdits __encodages__ est à l'origine même de certains compromis.

//

Commençons par la base.

Un bit est symboliquement représenté par un $0$ ou un $1$, pour la culture, je précise que le terme __bit__ vient de la contraction de __binary digit__ (__chiffre binaire__ en français).
Un champ binaire est quant à lui composé d'un ensemble de bit, c'est-à-dire d'un ensemble de $0$ et de $1$.
Ce sont ces champs binaires qui nous permettent de représenter des nombres dans un ordinateur, et par extension de faire des calculs ainsi que de mémoriser des résultats.

Il y a cependant de nombreuses façons de représenter des nombres dans un champ binaire, nous parlons de l'__encodage__ des nombres.
Tous les __encodages__ ne se valent pas car il y en a des plus adaptés/efficaces que d'autres en fonction des besoins.
Par exemple, pour représenter des nombres entiers naturels dans un champ de $N$ bits, nous pourrions simplement calculer la somme des bits qui compose le champ.
Cependant, cet __encodage__ ne remplit aucun cahier des charges et risque d'être sous optimal pour bien des situations.

Dans un premier temps, nous allons expliqués comment fonctionnent deux des __encodages__ les plus connus : le __binary unsigned__ ainsi que la __virgule flottante__.
Ces __encodages__ sont néanmoins intrinséquement liés au concept de la __notation positionnelle__, ce qui nous pousse à évoquer ce sujet avant même celui desdits __encodages__.

## La notation positionnelle

La __notation positionnelle__ est une sorte d'__encodage__ qui permet de représenter les nombres de façon générique sous n'importe quel base numérique.
Veuillez noté que la __notation positionnelle__ n'est pas la seule manière qui nous est donné pour représenter des nombres, il existe aussi la __notation scientifique__ qui, comme son nom l'indique, est principalement utilisée dans le monde des sciences ; le document consacre plus loin un chapitre entier à la __notation scientifique__.

Dans notre quotidien, lorsque nous manipulons des nombres (en base décimale) nous les représentons usuellement en __notation positionnelle__, comme ceci avec le nombre $23.75$ par exemple.
Il s'avère qu'en __notation positionnelle__, chaque chiffre constituant le nombre $23.75$ est facteur d'une puissance de $10_{10}$ car ledit nombre est écrit en base décimale, en base $10_{10}$ ; les chiffres constitutifs d'un nombre écrit en base $N$ étant facteurs d'une puissance de $N$.
Plus bas, nous verrons que ces puissances là peuvent être positives, nulles, ou bien négatives, tout ne dépend que du chiffre facteur de ladite puissance.
Enfin, le nombre sous-jacent a pour valeur la somme des produits entre chiffres et puissances.
Voici une illustration qui montre comment est-ce-que la valeur du nombre $23.75$ se déduit en base décimale :

$$23.75 \ = \left(\underline{2} \times 10_{10}^{\quad 1} + \underline{3} \times 10_{10}^{\quad 0} + \underline{7} \times 10_{10}^{\quad -1} + \underline{5} \times 10_{10}^{\quad -2}\right)$$

Notez que la syntaxe suivante $X_{10}$ spécifie la base numérique dans laquelle le nombre $X$ est écrit, $10$ pour la base décimale et $2$ pour la base binaire.
Cette syntaxe ne sera utilisée que lorsqu'il y aura une ambiguïté dans l'interprétation d'un nombre composé uniquement de $0$ et de $1$, permettant ainsi de dissocier les nombres écrits en base décimale de ceux écrits en base binaire.

Dans l'illustration qui figure ci-dessus, remarquez que les chiffres de la partie entière du nombre multiplient des puissances de $10_{10}$ positives ou nulles, tandis que les chiffres de la partie décimale multiplient exclusivement des puissances de $10_{10}$ négatives.
Cela s'explique par le fait que les chiffres de la partie entière du nombre $23.75$ requièrent de multiplier des nombres entiers, comme ceux résultants des puissances de $10_{10}$ positives et nulles.
Dans la même veine, les chiffres de la partie décimale du nombre nécessitent quant à eux de multiplier des nombres fractionnaires compris dans l'intervalle $\left]0;1\right[$, des puissances de $10_{10}$ négatives en l'occurrence.
Ce qui précède nous fait comprendre que de manière plus général, tout chiffre constituant la partie entière d'un nombre écrit en base $N$ est facteur d'une puissance de $N$ positive ou nulle, tandis que tout chiffre constituant la partie fractionnaire est facteur d'une puissance de $N$ négative. 

A cela, ajoutons que les valeurs des puissances de $10_{10}$ multipliées par deux chiffres successifs composant le nombre $23.75$, sont séparées d'un facteur $10_{10}$ ; pour généralisé, les valeurs des puissances de $N$ multipliées par deux chiffres successifs constituant un nombre écrit en base $N$, sont séparées d'un facteur $N$.

Par ailleurs, en plus d'expliquer le fonctionnement de la __notation positionnelle__, ce chapitre parle également de l'une des propriétés de cette notation.
Souvenez-vous du fait que la __notation positionnelle__ s'applique à toutes les bases numériques, ce qui insinue que ladite propriété s'applique elle aussi à l'ensemble des bases numériques.
En l'occurrence, cette propriété nous dit que dans tout nombre écrit en base $N$ : la valeur d'un chiffre non nul de poids $i$ est strictement supérieur à la somme des valeurs des chiffres de poids inférieur à $i$.

A ce stade nous savons que tout chiffre constitutif d'un nombre écrit en base $N$ est le facteur d'une puissance de $N$, la valeur d'un chiffre n'est rien de plus que le produit entre ledit chiffre et la puissance de $N$ dont il est le facteur.
Quant au poids d'un chiffre, celui-ci fait référence à l'exposant de la puissance de $N$ dont ledit chiffre est facteur, en __notation positionnelle__ le poids est un moyen universel d'indexer un chiffre dans un nombre, nonobstant la base numérique utilisée.
Prenons pour exemple le chiffre des unités du nombre décimale $23.75$, il se trouve que la valeur de ce chiffre est de $\left(3 \times 10_{10}^{\quad 0}\right)$ tandis que le poids de ce dernier est de $0$.

Avec tout cela en tête, constatons que la valeur du chiffre non nul de poids $0$ du nombre décimale $23.75$ est bel et bien strictement supérieur à la somme des valeurs des chiffres de poids inférieur à $0$ :

$$\left(3 \times 10_{10}^{\quad 0}\right) \gt \left(7 \times 10_{10}^{\quad -1} + 5 \times 10_{10}^{\quad -2}\right)$$

### L'encodage binary unsigned

Grâce au chapitre précédent nous savons désormais ce qu'est la __notation positionnelle__, et qui plus est, qu'elle s'applique à n'importe quel base numérique.
En l'occurrence, il s'avère que le __binary unsigned__ est un encodage qui représente des nombres entiers naturel en base binaire, et ce, par le biais de la __notation positionnelle__.
Comprendre l'encodage __binary unsigned__ demande donc de comprendre comment est-ce-que la __notation positionnelle__ représente des nombres entiers naturel en base binaire.

Le chapitre précédent nous fait comprendre qu'en __notation positionnelle__ : tout chiffre constitutif d'un nombre entier écrit en base $N$ est facteur d'une puissance de $N$ positive ou nulle.
En reportant ceci à tout nombre entier naturel écrit en base $2$, nous en déduisons que l'ensemble des bits qui composent un tel nombre sont facteurs d'une puissance de $2$ positive ou nulle.
La valeur d'un nombre entier naturel écrit en base $2$ n'est alors plus que la somme des produits entre bits et puissance.
Voici une illustration qui montre comment est-ce que le nombre $23$, sous l'impulsion de la __notation positionnelle__, s'écrit en base binaire :

$$10111_2 \ = \left(\underline{1} \times 2^4 + \underline{0} \times 2^3 + \underline{1} \times 2^2 + \underline{1} \times 2^1 + \underline{1} \times 2^0\right)$$

En outre, je vous rappelle qu'en __notation positionnelle__ il existe un système de poids, ce dernier permettant l'indexation de tout chiffre dans tout nombre peu importe la base numérique.
Il y a dans ce système un poids qui est attribué à tout chiffre constituant un nombre écrit en base $N$, dans un tel nombre le poids d'un chiffre n'est autre que l'exposant de la puissance de $N$ dont ledit chiffre est facteur.
En complément du système de poids, il existe en base binaire des termes qui font référence à certains des bits constituant un nombre.
Parmis les plus connus d'entre eux figure le terme __Least Significant Bit__ (de l'acronyme __LSB__) qui fait référence au bit de poids le plus faible d'un nombre, mais aussi le terme __Most Significant Bit__ (de l'acronyme __MSB__) qui fait quant à lui référence au bit de poids le plus fort d'un nombre.
Dans la lignée des termes précédent, l'acronyme __LSB1__ fait référence au bit à $1$ de poids le plus faible d'un nombre, tandis que l'acronyme __MSB1__ fait référence au bit à $1$ de poids le plus fort.

Enfin, n'oublions pas que la __notation positionnelle__ a une propriété dont nous avons déjà parlé dans le chapitre précédent.
Il s'avère que cette propriété s'applique à l'encodage __binary unsigned__, car je vous rappelle que c'est par le biais de la __notation positionnelle__ que cet encodage représente des nombres entiers naturel en base binaire.
Lorsqu'elle est appliquée à la base binaire, cette propriété nous dit (entre autre) que dans tout nombre entiers naturel binaire, ou autrement dit dans tout nombre __binary unsigned__ : la valeur d'un bit à $1$ de poids $i$ est strictement supérieur à la somme des valeurs des bits de poids inférieur à $i$.

Selon cette propriété, la valeur du bit à $1$ de poids $4$ du nombre entier naturel binaire $10111_2$ est strictement supérieur à la somme des valeurs des bits de poids inférieur à $4$, ce qui se vérifie :

$$\left(1 \times 2^4\right) \gt \left(0 \times 2^3 + 1 \times 2^2 + 1 \times 2^1 + 1 \times 2^0\right)$$

A ce stade, si vous avez du mal à comprendre cette section, je vous conseille de relire tout ou partie du précédent chapitre qui rentre plus dans le détails sur certains sujets, dont celui de ladite propriété.

Terminons cette section par un petit point de culture général.
Le nom __binary unsigned__ de l'encodage à l'étude dans cette section (__binaire non signé__ en français), vient du fait que ledit encodage ne permette pas la représentation des signes $\pm$.
Cette absence de signe explique pourquoi est-ce que cet encodage ne représente que des nombres entiers naturel, et non relatif.
A propos des nombres relatifs, ces derniers utilisent la plupart du temps un encodage en complément à deux, dont nous ne parlerons pas dans ce document.
